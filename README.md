# Dianping：点评网站后端服务
本项目是 [黑马程序员的 Redis 课程](https://www.bilibili.com/video/BV1cr4y1671t) 中的实战项目，目的主要是学习 Redis 的实际使用。 这个项目涵盖的知识不局限于 Redis，还包括 Spring Web MVC 框架的使用、并发编程以及 Redisson 等。将这个项目一步一步实现，能够对这些知识有一个总体上的理解。

## 主要内容
### 功能点
* 用户登录
  * 密码登录
  * 手机号登录
  * 基于 Session 和拦截器的登录状态校验
* 商户信息缓存
  * 缓存更新策略
  * 防止「缓存穿透」
  * 防止「缓存击穿」
* 优惠券秒杀
  * 全局唯一 ID
  * 防止「超售」
  * 保证「一人一单」
  * 分布式锁
  * 异步下单

### 进度
- [x] 用户登录
- [x] 商户信息缓存
- [x] 优惠券秒杀
- [ ] 笔记点赞排行
- [ ] 好友关注
- [ ] 附近商铺
- [ ] 用户签到
- [ ] UV 统计
- [ ] 分布式缓存
- [ ] 多级缓存

## 我们使用 Redis 存放哪些数据？ 
在我们这个应用中，Redis 用于存放以下数据：
* 用户使用手机号登录时的验证码
* 已登录用户的用户信息
* 商户类型的信息
* 商户信息
* 热点商户信息（用于防止缓存击穿）
* 一天内的订单总数（用于生成订单业务的全局唯一 ID）

上面提到的数据笼统说来都算是一种缓存，我们可以借此体会一下 Redis 的使用场景。

## 用户登录

后端视角下的登录动作，其实是向 Redis 中写入相应用户的记录，并设定一定的过期时间，代表一个 session。
一旦用户在这段时间内没有任何访问或操作，则将 Redis 中的记录删除，代表 session 结束。

### Redis 在这一部分的作用
我们选择用 Redis 而非 MySQL 来存放发送给用户的验证码以及用户的 token。理由是这类数据都是有时效性的，超过设定时间会过期，
而这一性质正好符合 Redis 的使用场景。

### 使用拦截器校验用户登录状态
这里使用的拦截器基于 Spring MVC 提供的 [HandlerInterceptor](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-handlermapping-interceptor)
接口。我们定义了两个拦截器：
1. `UserBindingInterceptor`：拦截对所有后端接口的请求，如果带有合法 token 则将相应的用户信息注入到当前线程，刷新 Redis 中登录用户记录的过期时间，否则放行到下一拦截器。
2. `LoginCheckInterceptor`：拦截对需要登录的接口的请求，避免每个功能都得单独校验用户的登录状态。如果未登录则不予放行。

这里同时用到了 `ThreadLocal` 类，属于 Java 并发的知识。

## 商户信息缓存
将之前从 MySQL 中查询到的商户信息存放至 Redis 作为缓存，以提高访问速度，增加并发能力。

当然，不是所有数据都适合放到缓存中，我们需要权衡成本和收益。对于经常请求而不经常变动的数据就很适合放在缓存中。

### 缓存更新策略
采取主动更新的策略以保持 MySQL 和 Redis 中数据的一致性。
具体地，每次修改 MySQL 数据时，同时删除 Redis 中相应记录（而非更新）。
注意这两步操作也是有先后顺序的：先修改 MySQL 记录，后删除 Redis 记录，这样能**最大限度地**减少出现数据不一致的可能性。
除此之外，对于 Redis 中的缓存设置过期时间，进一步保证数据的一致性。

### 防止缓存穿透
缓存穿透问题是指用户反复请求数据库和缓存中都不存在的数据时，给数据库造成较大压力的情况。针对缓存穿透，有以下几种解决方案：
* 用户请求这类数据时，在缓存中缓存空值
* 布隆过滤
* 增强数据 ID 的复杂度，同时在后端进行请求数据 ID 的格式校验
* 对数据请求做权限管理

我们这里采取简单的「缓存空值」方案，它具有实现简单的优点，但同时会带来一定的内存成本和数据不一致的可能。

### 防止缓存击穿
缓存击穿问题也称为「热点 Key」问题，指一个**被高并发访问**且缓存重建过程较复杂的 key 失效时，无数的请求会在瞬间给数据库造成巨大的冲击。
常见的解决方案有两种：
* 互斥锁：只让一个请求线程做缓存重建工作。
* 逻辑过期：对热点 key 不设置过期时间，相反，在数据中使用一个字段表示逻辑过期时间并在后端判断缓存是否过期。一个线程发现缓存过期时，不会等待缓存重建，而是直接拿过期的数据，并使用一个新的线程去做缓存重建工作（当然这个过程也需要使用互斥锁）。

互斥锁实现起来比较简单，没有额外的内存消耗，但会有互相等待的问题，性能较差，且有发生死锁的可能。
使用逻辑过期的策略，线程无需等待所以性能较好，但是实现复杂，有额外内存消耗，且不保证数据的一致性。
这两种方案的选择更多的是一致性和可用性之间的权衡，应根据自己的需求和侧重点来选择。

关于缓存击穿到底是什么样子，可以将查询商户信息的接口设置为调用 `queryShopWithoutPenetration` 方法，删除 Redis 中某一个商户的缓存，
然后使用 JMeter 模拟高并发请求进行测试。我设置在 1 秒之内进行 100 次请求，结果有 57 条请求未命中缓存并去查询了 MySQL 然后将其写入 Redis，
只有剩下 43 次请求命中了 Redis。 可以看到在高并发场景下，热点 key 失效会对 MySQL 造成巨大压力。

作为对比，调用 `queryShopWithoutBreakdown` 方法时，面对同样的 100 次请求，只有第一次请求去 MySQL 中查询，后面的 99 次请求均在 Redis 中命中，
防止了缓存击穿的问题；调用 `queryShopWithoutBreakdown2` 方法时，所有的请求都因为缓存过期而在请求互斥锁，但是只有一个线程获取锁成功并刷新缓存，
其他的线程不会等待，拿到了过时的数据。


## 优惠券秒杀
### 全局唯一 ID
在我们的业务中，订单等实体需要一个全局唯一的 ID，即不同订单的 ID 不能冲突。通常，我们在使用 MySQL 存储业务数据时会通过主键自增的方式来配置 ID。
但随着业务规模的扩大，MySQL 这类数据库可能会需要分库分表以及集群化的部署，这时在不同的 MySQL 服务器以及不同的表中保证实体 ID 的唯一性将会很难。 

Redis 并不存在表的概念，所有的数据都存放在一起，同时其 `INCR` 命令可以轻松实现 ID 自增，因此可以使用 Redis 来生成全局唯一 ID。其实还有其他的方案
可以满足我们的需求，比如 UUID。UUID 是一串 32 个字符（128 bit）的字符串，但是相比于我们的方案生成的 `long` 型 ID，在 MySQL 中的查询效率会更低。

对于某一类业务实体，这里用订单举例，我们用一个 `long` 来存放其全局唯一 ID。一个长整形数是 8 个字节，64 位，我们用最高位作为符号位，中间的 31 位
表示时间戳（指该订单创建时间与指定的开始时间之间的时间差），低位的 32 位存放同一秒内的订单序号（即可以保证一秒内有最多 2^32 个订单产生）。

### 一个小细节
更新库存的步骤，我自己写的代码是：
```
voucher.setStock(voucher.getStock() - 1);
limitedVoucherService.updateById(voucher);
```
这种写法更新效率比较低。更好的写法是：
```
limitedVoucherService.update()
   .setSql("stock = stock - 1")
   .eq("voucher_id", voucherId)
   .update();
```
另外，运行在本机的 MySQL 和运行在远程服务器上的 MySQL 之间有非常大的性能差距。同样是两百个线程同时进行下单优惠券的操作，
把 MySQL 运行在本机时只需要 4 秒，而把 MySQL 运行在远程服务器上时则需要 12 秒。

### 使用乐观锁思想避免超售现象
优惠券下单的业务逻辑十分简单：
1. 去 MySQL 中查询某一优惠券的信息，检查售卖的开始结束时间以及库存，如果不在设定时间内或库存不足则返回错误信息；
2. 更新库存；
3. 创建一个新订单，这时即说明下单成功。

但是，目前的代码中存在**线程安全性问题**。先校验库存然后修改库存是一种常见的 **"check-then-act"** 操作，实际上由好几条指令构成，不具备原子性。在高并发的状态下，大量请求同时查询库存，如果不采取适当的同步措施，不同线程间的操作可能出现**交替 (overlapping)**，从而导致"查询到还有库存但实际已经没有库存"的情况发生，结果就是卖出了超出库存数量的优惠券，即「超售」。超售只是**线程安全性问题**的其中一种表现形式。

> **安全性问题 (safety hazards)** 是多线程编程的三种风险之一，另外两个是 **性能问题 (performance hazards)** 和 **活跃性问题 (liveness hazards)**。

我使用 JMeter 进行测试，设置 100 个库存，然后用 200 个并发线程去下单优惠券，最终售出了 109 张优惠券，超售 9 张。

要保证程序的线程安全性，避免产生「超售」现象，使用**锁机制 (locking)** 是一个很容易想到的方案。这里的「锁」是一种思想。
根据面对线程安全性问题时所持有的态度、采取的策略，可以将锁机制分为乐观锁和悲观锁。
- **悲观锁**：认为线程安全问题一定会发生，因此在修改数据之前先获取锁，确保线程**串行**执行，效率较低。
- **乐观锁**：认为线程安全问题不一定会发生，因此不加锁，只是在修改数据时判断一下有没有其他线程修改了这个数据，如果未被修改则认为是安全的，否则重试或返回异常。

我们这里使用**改进的乐观锁**来解决超售问题。在查询库存的基础上，在修改库存的 SQL 语句中添加一个库存大于 0 的条件，只要这个条件满足即说明当前是真的还有库存。

### 一人一单
对于某种优惠券，我们需要限制同一用户仅能购买一张，即「一人一单」。
与上面所提到的「超售」现象类似，当用户使用特殊手段在短时间内发起大量请求购买优惠券时，同样可能出现同一用户买到不止一张优惠券的现象（本质上也是一种「超售」）。

#### 使用同步代码块保证一人一单
这里，使用**同步代码块 (synchronized block)** 可以很容易地避免并发情况下的「线程干扰」。

> 同步代码块 (synchronized block) 是 **Java 内置的一种锁机制**。在代码中使用 `synchronized` 关键字即可保证不同线程之间同步地（串行地）执行代码块。

> 但测试后发现使用同步似乎还是不能完全避免这个问题，存在同一用户能下两单的情况。不知道原因是什么。

#### 分布式锁
目前，使用同步代码块解决了「一人一单」的问题，但是如果未来应用需要集群化部署时，应用分别运行在不同的**进程**中，此时同步代码块不再能保证不同进程中的线程之间串行执行业务了。
此时，我们需要一个**不同进程中的所有线程都可申请的互斥锁**来保证线程安全，这个办法就是 —— **分布式锁 (Distributed Locking)**。

分布式锁有不同的实现方式，使用 MySQL、Redis 和 ZooKeeper 都能实现该功能，但各有优缺点，可以试着分析一下不同实现方式之间的差异。对于分布式锁的不同实现，评价指标主要是：
* 互斥的实现方式
* 可用性
* 性能
* 安全性

[参考文章](https://redis.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-2-distributed-locking/)

一、基于 Redis 实现分布式锁

做这个项目的主要目的是学习 Redis 的使用，因此我们这里使用 Redis 来实现。具体地，我们使用 Redis 中的一条记录作为锁，key 为锁的标识，value 为持有这把锁的线程标识。线程在获取分布式锁时需设置锁的超时时间避免出现死锁；解锁时需先校验锁的持有人，防止误删。

但此时还存在问题。释放锁的过程在 Java 代码中其实是两步操作：1）在 Redis 中查询这把锁的持有线程并与自身校验；2）删除这把锁在 Redis 中的记录。考虑这样一种情况：线程 A 获取分布式锁成功并执行完业务准备释放锁，当校验完分布式锁的持有线程后，JVM 的垃圾回收机制导致线程被阻塞，阻塞过程中该锁超时被释放，此时线程 B 趁虚而入，获取到该锁，等线程 A 恢复运行时直接将 Redis 中属于线程 B 的锁删除。完全乱套了。

产生这种问题的原因是，释放锁的两步操作在 Java 代码中似乎具有原子性，但分布式锁位于外部的 Redis 中，超时机制导致在 Redis 中这两步操作还是不具有原子性。所以，我们需要保证**在 Redis 中**查询记录和删除记录这两个动作具有原子性。这里，我们采用的解决方案是：将解锁操作放在 **Lua 脚本**中执行。

二、使用 Redisson 提供的分布式锁

到这里为止，我们已经实现了一个可用的分布式锁。但是必须指出的是，这种实现还有改进的空间，包括：
* 当前的分布式锁是不可重入的。
* 获取锁失败时没有重试机制。
* Redis 中锁记录的过期时间的选取需要好好权衡：过短，业务尚未完成锁可能就被释放了；过长，若执行线程出现故障导致其他线程一直等待。
* 当部署 Redis 的主从集群时，由于主从同步具有延迟，若主节点宕机导致主从数据不同步，则会出现线程安全性问题。

针对以上几个缺陷，我们可以使用 Redisson 提供的分布式锁的实现。

> [Redisson](https://github.com/redisson/redisson) 是 Redis 的一个 Java 客户端，
> 基于 Redis 实现了一系列常用的分布式集合和工具。

有兴趣可以看一些 Redisson 中 `RedissonLock` 的具体实现细节，还是很复杂的。这也是为什么我们要用现成的方案，而不是自己实现。

### 使用异步策略提高业务的并发能力
目前的优惠券秒杀逻辑可以总结如下：
1. 在 MySQL 的优惠券表中**查询**欲购买的优惠券开放购买时间、结束时间、库存； 
2. （获取分布式锁）在 MySQL 的订单表中**查询**是否存在该用户购买该优惠券的订单； 
3. 对 MySQL 的优惠券表做**写入**操作，扣减库存； 
4. 对 MySQL 的订单表做**写入**操作，创建订单（释放分布式锁）。

对于每个购买优惠券的请求我们都用一个线程从上至下执行这四个操作来完成处理，而对 MySQL 数据库的读写本身就是较慢的，一次请求的处理涉及到两次读操作和两次写操作，可想而知一次请求的处理时间会有多慢。况且很多请求进行两次查询后是不用再进行后面两步写操作的，那我们能不能将查询优惠券开放购买时间以及库存的读操作与扣减库存、创建订单的写操作**拆分**开来，利用多线程的优势加速业务的处理呢？

因此，我们可以这样优化我们的业务逻辑：将前两步查询所需的信息**缓存至 Redis 中**以加速查询。当该用户没有购买该优惠券的资格时则可以直接返回；如果有则直接生成一个订单号返回给用户告知其购买成功，然后将扣减库存和创建订单的任务**交由专门的线程异步去完成**，自己则可以接着去接收新的请求。这种异步的策略能够大大提高服务的吞吐量和并发能力。优化后的优惠券秒杀逻辑如下：
1. 在 Redis 中查询该优惠券的库存
2. 在 Redis 中查询该用户是否购买过该优惠券
3. 修改 Redis 中的库存信息和订单信息
4. 将下单任务添加至阻塞队列

### 使用 Redis 作为消息队列
目前，我们使用 JDK 中的 `BlockingQueue` 作为下单任务的队列，这种方式存在一些问题：
* 受限于 JVM 的内存上限，在高并发的场景下可能导致内存溢出
* 消息没有持久化，存在数据安全问题，如果服务出现宕机消息会丢失

为了解决这些问题，我们可以使用专门的消息队列中间件，比如 RabbitMQ。其实 Redis 也提供了一些数据类型可以作为消息队列使用。

#### 使用 List 数据类型进行模拟
使用 Redis 中的 List 类型，搭配 `RPUSH` 和 `BLPOP` 命令可以简单地模拟出消息队列的效果。这也只是一种简单的实现。

#### 使用 Pub/Sub 
发布-订阅 (publish-subscribe) 是一种消息范式，在这种模式下，消息的发布者将消息发送至特定的频道 (channel)，所有正在监听（即订阅）该频道的消费者都会收到该消息。需要注意的是，这种模式具有实时性，消息一旦发出是不可回溯的，所以订阅者无法收到历史消息。

Redis 中的 pub/sub 是对发布订阅范式的一种实现，而不是像 LIST、SET 这种数据存储的类型。利用 `PUBLISH`、`SUBSCRIBE`、`PSUBSCRIBE` 等命令可以将 Redis 当作一种简单的、特殊的消息队列使用。

#### 使用 Stream
Stream 是 Redis 5.0 版本加入的一种数据类型，借助 Stream 提供的功能我们可以得到一个功能全面的消息队列。消息队列不是 stream 唯一的用法。

Stream 作为一个消息队列使用时，具有以下特点：
* stream 中的 entry 可以被多个消费者消费，这一点和 pub/sub 类似。
* 加入到 stream 中的 entry 是被无限期保存的，除非手动删除。对于不同的消费者，Redis 会维护各自所消费的最后一个 entry，所以从不同的消费者的视角看来，各自有不同的消费状态。
* 相比于 List 和 Pub/Sub，提供了更高级的控制能力，例如：对消费组进行分组，对消息的确认机制等。

一个 stream 本质上就是许多条 entry 的列表，不同的消费者组则可以想象成是一个 stream 不同的状态。这里，我们用 Redis 中的 stream 替代之前用的 JDK 的 `BlockingQueue`，同时利用线程池的多个线程作为一个消费者组从 stream 中拿还未处理完成的订单。

## 笔记点赞排行

### 使用 Sorted Set 存储给笔记点赞的用户列表
在笔记的详情页需要展示笔记的点赞人数，以及最早点赞的若干个用户的头像。我们使用 Redis 中的有序集合 Sorted Set 存放每篇笔记的点赞用户，将各用户的点赞时间戳作为集合元素的分数从而进行排序。