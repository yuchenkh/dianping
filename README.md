# Dianping：点评网站后端服务
[黑马程序员 Redis 课程](https://www.bilibili.com/video/BV1cr4y1671t?p=25&share_source=copy_web)

## 主要内容
* 用户登录
  * 密码登录
  * 手机号登录
  * 基于 Session 和拦截器的登录状态校验

- [ ] 用户登录
- [ ] 商户查询缓存
- [ ] 优惠券秒杀
- [ ] 分布式锁
- [ ] 消息队列
- [ ] 达人探店
- [ ] 好友关注
- [ ] 附近商铺
- [ ] 用户签到
- [ ] UV 统计
- [ ] 分布式缓存
- [ ] 多级缓存

## 用户登录

后端视角下的登录动作，其实是向 Redis 中写入相应用户的记录，并设定一定的过期时间，代表一个 session。
一旦用户在这段时间内没有任何访问或操作，则将 Redis 中的记录删除，代表 session 结束。

### Redis 在这一部分的作用
我们选择用 Redis 而非 MySQL 来存放发送给用户的验证码以及用户的 token。理由是这类数据都是有时效性的，超过设定时间会过期，
而这一性质正好符合 Redis 的使用场景。

### 使用拦截器校验用户登录状态
这里使用的拦截器基于 Spring MVC 提供的 [HandlerInterceptor](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-handlermapping-interceptor)
，我们定义了两个拦截器：
1. `AccessInterceptor`：拦截对所有后端接口的请求，如果带有合法 token 则刷新其过期时间，否则放行到下一拦截器。
2. `LoginInterceptor`：拦截对需要登录的接口的请求，避免每个功能都得单独校验用户的登录状态。如果未登录则不予放行。

这里同时用到了 `ThreadLocal` 类，属于 Java 并发的知识。

## 商户信息缓存
将之前从 MySQL 中查询到的商户信息存放至 Redis 作为缓存，以提高访问速度，增加并发能力。

当然，不是所有数据都适合放到缓存中，我们需要权衡成本和收益。对于经常请求而不经常变动的数据就很适合放在缓存中。

### 缓存更新策略
采取主动更新的策略以保持 MySQL 和 Redis 中数据的一致性。
具体地，每次修改 MySQL 数据时，同时删除 Redis 中相应记录（而非更新）。
注意这两步操作也是有先后顺序的：先修改 MySQL 记录，后删除 Redis 记录，这样能**最大限度地**减少出现数据不一致的可能性。
除此之外，对于 Redis 中的缓存设置过期时间，进一步保证数据的一致性。

### 防止缓存穿透
缓存穿透问题是指用户反复请求数据库和缓存中都不存在的数据时，给数据库造成较大压力的情况。针对缓存穿透，有以下几种解决方案：
* 用户请求这类数据时，在缓存中缓存空值
* 布隆过滤
* 增强数据 ID 的复杂度，同时在后端进行请求数据 ID 的格式校验
* 对数据请求做权限管理

我们这里采取简单的「缓存空值」方案，它具有实现简单的优点，但同时会带来一定的内存成本和数据不一致的可能。

### 防止缓存击穿
缓存击穿问题也称为「热点 Key」问题，指一个**被高并发访问**且缓存重建过程较复杂的 key 失效时，无数的请求会在瞬间给数据库造成巨大的冲击。
常见的解决方案有两种：
* 互斥锁：只让一个请求线程做缓存重建工作。
* 逻辑过期：对热点 key 不设置过期时间，相反，在数据中使用一个字段表示逻辑过期时间并在后端判断缓存是否过期。
* 一个线程发现缓存过期时，不会等待缓存重建，而是直接拿过期的数据，并使用一个新的线程去做缓存重建工作（当然这个过程也需要使用互斥锁）。

互斥锁实现起来比较简单，没有额外的内存消耗，但会有互相等待的问题，性能较差，且有发生死锁的可能。
使用逻辑过期的策略，线程无需等待所以性能较好，但是实现复杂，有额外内存消耗，且不保证数据的一致性。
这两种方案的选择更多的是一致性和可用性之间的权衡，应根据自己的需求和侧重点来选择。

关于缓存击穿到底是什么样子，可以将查询商户信息的接口设置为调用 `queryShopWithoutPenetration` 方法，删除 Redis 中某一个商户的缓存，
然后使用 JMeter 模拟高并发请求进行测试。我设置在 1 秒之内进行 100 次请求，结果有 57 条请求未命中缓存并去查询了 MySQL 然后将其写入 Redis，
只有剩下 43 次请求命中了 Redis。 可以看到在高并发场景下，热点 key 失效会对 MySQL 造成巨大压力。

作为对比，调用 `queryShopWithoutBreakdown` 方法时，面对同样的 100 次请求，只有第一次请求去 MySQL 中查询，后面的 99 次请求均在 Redis 中命中，
防止了缓存击穿的问题；调用 `queryShopWithoutBreakdown2` 方法时，所有的请求都因为缓存过期而在请求互斥锁，但是只有一个线程获取锁成功并刷新缓存，
其他的线程不会等待，拿到了过时的数据。


